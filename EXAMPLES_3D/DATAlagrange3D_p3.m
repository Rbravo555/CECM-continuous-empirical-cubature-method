DATA_ECM.ACTIVE =1;  % Enable the continuous empirical cubature method
DATA_ECM.TOL_SVD_A =0 ; % Tolerance SVD data matrix  (here the SVD only plays the role of orthogonalization, so we may set it to zero )
DATA_ECM.UsePartitionedRandomizedAlgorithm = 0 ;  % Use advanced partitioned SVD (not needed if the matrix is relatively small) 
DATA_ECM.TOL_NewtonRaphson_EliminationPoints = 1e-8 ;  % Tolerance for the Newton-Raphson algorithm
DATA_ECM.MaxIterationsNR_ElimPoints = 40 ;  % Number of iteration for each NR step
DATA_ECM.SECOND_STAGE_ITERATIONS  = 20 ;   % Number of steps for each weight elimination in the second stage

% -------------------------------------------------
% FINITE ELEMENT MESH DATA  
% -------------------------------------------------
% Required inputs. 
% 1. Matrix of nodal coordinates 
% DATA.MESH.COOR = [x1 y1 z1;  x2 y2 z3; x3 y3 z3; ...]
% 2. Connectivity matrix (as many rows as finite elements )
% DATA.MESH.CN   = [elem1_node1 elem1_node2 ... elem1_node_nnodeE...   
%                   elem2_node1 elem2_node2 ... elem2_node_nnodeE ...
%                   .... .... ..... .... ] 
% 3. Type of finite element 
% DATA.MESH.TypeElement = 'Hexahedra'  ; %   

% Here we obtain these data from the pre-processor program "GID" https://www.gidsimulation.com/
NameMesh =['GIDFILES/CUBE_20_20_20.msh'] ; % ASCII file containing the mesh information (generated by option "Export")
[DATA.MESH]= ReadMeshFileStr(NameMesh,'READ_MATERIAL_COLUMN',1)  ;  
% Number of Gauss points per finite element 
DATA.NumberOfGaussPointsPerElement = [2,2,2] ; % For fitting purposes, as well as for providing the initial integration rule 
% -------------------------------------------------------------------------------------------------
% DATA CONCERNING THE INTEGRAND FUNCTION 
% -------------------------------------
DATA_ECM.Method_Evaluation_Basis_Integrand =2; % Evaluation method % 1 --> FE fitting   / 2 ---> Analytical evaluation  
DATA.Integrand.NameFunctionGenerate  = 'LagrangePolynomial3Dgen' ; % Function to be evaluated at the Gauss points of
% each element. In this case,   'LagrangePolynomial2Dgen' 
DATA.Integrand.PORDER  =  3 ;
xMIN = min(DATA.MESH.COOR(:,1)) ; xMAX = max(DATA.MESH.COOR(:,1)) ;
yMIN = min(DATA.MESH.COOR(:,2)) ; yMAX = max(DATA.MESH.COOR(:,2)) ;
zMIN = min(DATA.MESH.COOR(:,3)) ; zMAX = max(DATA.MESH.COOR(:,3)) ;
DATA.Integrand.xLIM = [xMIN,xMAX; yMIN,yMAX; zMIN,zMAX] ;  % Limits of integration


% PLOTTING THE EDGES OF THE DOMAIN
% LINEAR MESH, just one element  (8 NODES, for plotting the edges of the domain  )
NameMeshLOC =['GIDFILES/CUBE_1_1_1.msh'] ;
[MESHloc]= ReadMeshFileStr(NameMeshLOC,'READ_MATERIAL_COLUMN',1)  ; 
DATA_ECM.ContourMeshDomain = MESHloc ; 
LinesToPlot = [1 2; 2 3; 3 4; 4 1 ;  5 6; 6 7; 7 8; 8 5; 1 5; 2 6; 3 7; 4 8] ; 
MESHloc.LinesToPlot = MESHloc.CN(LinesToPlot) ; 
DATA_ECM.ContourMeshDomain = MESHloc ; 

 

% STANDARD GAUSS INTEGRATION  (for comparison purposes)
% ---------------------------
% We wish to assess also the accuracy of a standard GAussian rule 
NumberOfGaussPointsPerElement = ceil((DATA.Integrand.PORDER+1)/2) ; 
NumberOfGaussPointsPerElement = [NumberOfGaussPointsPerElement,NumberOfGaussPointsPerElement,NumberOfGaussPointsPerElement] ; 

[~, ~, xGAUSS, wGAUSS ]  =TensorProd3Ddiscr(NumberOfGaussPointsPerElement,DATA.Integrand.xLIM) ;
[xx,yy,zz]  = meshgrid(xGAUSS{1},xGAUSS{2},xGAUSS{3}) ;
xx = xx(:) ; yy = yy(:); zz = zz(:) ; 
posgp= [xx'; yy';zz'] ;
DATA_ECM.xGAUSS = posgp' ;DATA.xGAUSS  = DATA_ECM.xGAUSS ; 
DATA_ECM.wGAUSS = wGAUSS ; DATA.wGAUSS = wGAUSS 

 
 