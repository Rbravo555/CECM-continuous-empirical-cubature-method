DATA_ECM.ACTIVE =1;  % Enable the continuous empirical cubature method
DATA_ECM.TOL_SVD_A =0 ; % Tolerance SVD data matrix  (here the SVD only plays the role of orthogonalization, so we may set it to zero )
DATA_ECM.UsePartitionedRandomizedAlgorithm = 0 ;  % Use advanced partitioned SVD (not needed if the matrix is relatively small) 
DATA_ECM.TOL_NewtonRaphson_EliminationPoints = 1e-8 ;  % Tolerance for the Newton-Raphson algorithm
DATA_ECM.MaxIterationsNR_ElimPoints = 40 ;  % Number of iteration for each NR step
DATA_ECM.SECOND_STAGE_ITERATIONS  = 20 ;   % Number of steps for each weight elimination in the second stage

% -------------------------------------------------
% FINITE ELEMENT MESH DATA  
% -------------------------------------------------
% Required inputs. 
% 1. Matrix of nodal coordinates 
% DATA.MESH.COOR = [x1 y1;  x2 y2; x3 y3 ; ...]
% 2. Connectivity matrix (as many rows as finite elements )
% DATA.MESH.CN   = [elem1_node1 elem1_node2 ... elem1_node_nnodeE...   
%                   elem2_node1 elem2_node2 ... elem2_node_nnodeE ...
%                   .... .... ..... .... ] 
% 3. Type of finite element 
% DATA.MESH.TypeElement = 'Quadrilateral'  ; %  in 2D, either Quadrilateral or Triangle
% 4. Local numbering definining the boundary of the element  
% DATA.MESH.IND_POLYG_ELEMENT = [node1_polig node2_polig ... ]  
% For linear elements:  DATA.MESH.IND_POLYG_ELEMENT = [1 2 nnodeE 1] ;  

% Here we obtain these data from the pre-processor program "GID" https://www.gidsimulation.com/
NameMesh =['SQUARE/SQUARE_30_30.msh'] ; % ASCII file containing the mesh information (generated by option "Export")
[DATA.MESH]= ReadMeshFileStr_MULT(NameMesh,'READ_MATERIAL_COLUMN',1)  ;  
% Number of Gauss points per finite element 
DATA.NumberOfGaussPointsPerElement = [4,4] ; % For fitting purposes, as well as for providing the initial integration rule 
% -------------------------------------------------------------------------------------------------
% DATA CONCERNING THE INTEGRAND FUNCTION 
% -------------------------------------
DATA_ECM.Method_Evaluation_Basis_Integrand =2; % Evaluation method % 1 --> FE fitting   / 2 ---> Analytical evaluation  
DATA.Integrand.NameFunctionGenerate  = 'LagrangePolynomial2Dgen' ; % Function to be evaluated at the Gauss points of
% each element. In this case,   'LagrangePolynomial2Dgen' 
DATA.Integrand.PORDER  =  3;
xMIN = min(DATA.MESH.COOR(:,1)) ; xMAX = max(DATA.MESH.COOR(:,1)) ;
yMIN = min(DATA.MESH.COOR(:,2)) ; yMAX = max(DATA.MESH.COOR(:,2)) ;
DATA.Integrand.xLIM = [xMIN,xMAX; yMIN,yMAX] ;  % Limits of integration
 

% STANDARD GAUSS INTEGRATION  (for comparison purposes)
% ---------------------------
% We wish to assess also the accuracy of a standard GAussian rule 
NumberOfGaussPointsPerElement = ceil((DATA.Integrand.PORDER+1)/2) ; 
NumberOfGaussPointsPerElement = [NumberOfGaussPointsPerElement,NumberOfGaussPointsPerElement] ; 

[~, ~, xGAUSS, wGAUSS ]  =TensorProd2Ddiscr(NumberOfGaussPointsPerElement,DATA.Integrand.xLIM) ;
[xx,yy]  = meshgrid(xGAUSS{1},xGAUSS{2}) ;
xx = xx(:) ; yy = yy(:);
posgp= [xx'; yy'] ;
DATA.xGAUSS = posgp' ;
DATA.wGAUSS = wGAUSS ; 

 
 